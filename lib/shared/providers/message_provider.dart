import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../core/constants/constants.dart';
import '../models/message_model.dart';
import '../services/firebase_service.dart';
import '../services/in_app_notification_service.dart';

/// Provider for handling real-time messaging
class MessageProvider extends ChangeNotifier {
  final FirebaseService _firebaseService = FirebaseService.instance;
  
  // Current active conversation messages
  List<MessageModel> _messages = [];
  // User's conversation list
  List<ConversationModel> _conversations = [];
  
  bool _isLoading = false;
  String? _currentConversationId;

  List<MessageModel> get messages => _messages;
  List<ConversationModel> get conversations => _conversations;
  bool get isLoading => _isLoading;

  /// Listen to user's conversations
  Stream<List<ConversationModel>> streamConversations(String userId) {
    return _firebaseService
        .streamCollection(
          AppConstants.conversationsCollection,
          queryBuilder: (query) => query
              .where('participants', arrayContains: userId)
              .orderBy('updatedAt', descending: true),
        )
        .map((snapshot) => snapshot.docs
            .map((doc) => ConversationModel.fromFirestore(doc))
            .toList());
  }

  /// Listen to ALL conversations (for Admin)
  Stream<List<ConversationModel>> streamAllConversations() {
    return _firebaseService
        .streamCollection(
          AppConstants.conversationsCollection,
          queryBuilder: (query) => query
              .orderBy('updatedAt', descending: true),
        )
        .map((snapshot) => snapshot.docs
            .map((doc) => ConversationModel.fromFirestore(doc))
            .toList());
  }

  /// Listen to messages in a specific conversation
  Stream<List<MessageModel>> streamMessages(String conversationId) {
    _currentConversationId = conversationId;
    return _firebaseService
        .streamCollection(
          AppConstants.messagesCollection,
          queryBuilder: (query) => query
              .where('conversationId', isEqualTo: conversationId)
              .orderBy('createdAt', descending: true),
        )
        .map((snapshot) => snapshot.docs
            .map((doc) => MessageModel.fromFirestore(doc))
            .toList());
  }

  /// Send a message
  Future<void> sendMessage({
    required String conversationId,
    required String senderId,
    required String text,
    String? type = 'text',
    String? imageUrl,
  }) async {
    try {
      final message = MessageModel(
        id: '', // Generated by Firestore
        conversationId: conversationId,
        senderId: senderId,
        text: imageUrl ?? text,
        isImage: type == 'image',
        createdAt: DateTime.now(),
      );

      // Add to messages collection
      await _firebaseService.addDocument(
        AppConstants.messagesCollection,
        message.toMap(),
      );

      // Update conversation last message and increment unread count
      await _firebaseService.updateDocument(
        AppConstants.conversationsCollection,
        conversationId,
        {
          'lastMessage': {
            'id': '', 
            'senderId': senderId,
            'text': type == 'image' ? 'ðŸ“· Photo' : text,
            'isImage': type == 'image',
            'createdAt': FieldValue.serverTimestamp(),
          },
          'lastMessageTime': FieldValue.serverTimestamp(),
          'updatedAt': FieldValue.serverTimestamp(),
          'unreadCount': FieldValue.increment(1),
          'lastSenderId': senderId,
        },
      );

      final conversationDoc = await _firebaseService.getDocument(
        AppConstants.conversationsCollection,
        conversationId,
      );
      final participants = List<String>.from((conversationDoc.data() as Map<String, dynamic>?)?['participants'] ?? []);
      for (final participant in participants.where((id) => id != senderId)) {
        await InAppNotificationService.notifyUser(
          userId: participant,
          title: 'New message',
          body: type == 'image' ? 'You received a new photo message.' : text,
          type: 'chat',
          data: {'conversationId': conversationId},
        );
      }
    } catch (e) {
      debugPrint('Error sending message: $e');
      rethrow;
    }
  }

  /// Create a new conversation or get existing one
  Future<String> startConversation({
    required String currentUserId,
    required String otherUserId,
    required String otherUserName,
    required String otherUserRole,
  }) async {
    try {
      // Check if conversation already exists
      final querySnapshot = await _firebaseService.getCollection(
        AppConstants.conversationsCollection,
        queryBuilder: (query) => query
            .where('participants', arrayContains: currentUserId),
      );

      final duplicateDocs = querySnapshot.docs.where((doc) {
        final data = doc.data() as Map<String, dynamic>;
        final participants = List<String>.from(data['participants'] ?? []);
        return participants.contains(otherUserId);
      });

      if (duplicateDocs.isNotEmpty) {
        return duplicateDocs.first.id;
      }
      
      final conversation = ConversationModel(
        id: '', // Will be set by Firestore
        participants: [currentUserId, otherUserId],
        participantNames: {
          currentUserId: 'You',
          otherUserId: otherUserName,
        },
        lastMessage: null,
        updatedAt: DateTime.now(),
      );

      final docRef = await _firebaseService.addDocument(
        AppConstants.conversationsCollection,
        conversation.toMap(),
      );
      
      return docRef.id;
    } catch (e) {
      debugPrint('Error starting conversation: $e');
      rethrow;
    }
  }

  /// Mark messages as read
  Future<void> markAsRead(String conversationId, String userId) async {
    try {
      await _firebaseService.updateDocument(
        AppConstants.conversationsCollection,
        conversationId,
        {
          'unreadCount': 0,
        },
      );
    } catch (e) {
      debugPrint('Error marking as read: $e');
    }
  }
}
